name: Auto Assign

on:
  # Use pull_request_target for PRs to have write permissions on fork PRs
  # This is safe because we don't checkout or execute any code from the PR
  # We only use GitHub API to assign users and add labels
  pull_request_target:
    types: [opened, ready_for_review]
  issues:
    types: [opened]

permissions:
  issues: write
  pull-requests: write

jobs:
  assign:
    name: Auto-assign issues and PRs
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false || github.event_name == 'issues'
    steps:
      - name: Auto-assign issue or PR to author
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const author = context.payload.sender.login;

            // Get the issue or PR number
            const number = context.payload.issue?.number || context.payload.pull_request?.number;

            if (number) {
              try {
                await github.rest.issues.addAssignees({
                  owner,
                  repo,
                  issue_number: number,
                  assignees: [author]
                });
                console.log(`Assigned ${author} to ${context.payload.issue ? 'issue' : 'PR'} #${number}`);
              } catch (error) {
                console.log(`Failed to assign ${author}: ${error.message}`);
              }
            }

  label-pr:
    name: Label pull requests
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request_target'
    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Auto-label PR based on changes
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;

            // Get PR files
            const { data: files } = await github.rest.pulls.listFiles({
              owner,
              repo,
              pull_number: prNumber
            });

            const labels = [];

            // Get PR title and extract conventional commit type
            const prTitle = context.payload.pull_request.title;
            const conventionalCommitRegex = /^(\w+)(?:\(([^)]*)\))?(!)?:/;
            const match = prTitle.match(conventionalCommitRegex);

            if (match) {
              const [, type, scope, breaking] = match;

              // Add labels based on conventional commit type
              switch (type) {
                case 'feat':
                  labels.push('enhancement', 'feature');
                  break;
                case 'fix':
                  labels.push('bug', 'fix');
                  break;
                case 'docs':
                  labels.push('documentation');
                  break;
                case 'style':
                  labels.push('style', 'code-quality');
                  break;
                case 'refactor':
                  labels.push('refactor', 'code-quality');
                  break;
                case 'perf':
                  labels.push('performance');
                  break;
                case 'test':
                  labels.push('testing');
                  break;
                case 'build':
                  labels.push('build');
                  break;
                case 'ci':
                  labels.push('ci/cd');
                  break;
                case 'chore':
                  labels.push('maintenance');
                  break;
                case 'security':
                  labels.push('security');
                  break;
              }

              // Add scope-based labels
              if (scope) {
                switch (scope) {
                  case 'auth':
                    labels.push('authentication');
                    break;
                  case 'config':
                    labels.push('configuration');
                    break;
                  case 'cli':
                    labels.push('cli');
                    break;
                  case 'cache':
                    labels.push('caching');
                    break;
                  case 'security':
                    labels.push('security');
                    break;
                  case 'docs':
                    labels.push('documentation');
                    break;
                  case 'ci':
                    labels.push('ci/cd');
                    break;
                  case 'deps':
                    labels.push('dependencies');
                    break;
                }
              }

              // Add breaking change label
              if (breaking === '!') {
                labels.push('breaking-change', 'major');
              }
            }

            // Determine additional labels based on file changes
            for (const file of files) {
              const filename = file.filename;

              if (filename.includes('.github/workflows/')) {
                labels.push('ci/cd');
              } else if (filename.includes('docs/') || filename.endsWith('.md')) {
                labels.push('documentation');
              } else if (filename.includes('pkg/auth/')) {
                labels.push('authentication');
              } else if (filename.includes('pkg/config/')) {
                labels.push('configuration');
              } else if (filename.includes('cmd/')) {
                labels.push('cli');
              } else if (filename.includes('_test.go')) {
                labels.push('testing');
              } else if (filename.endsWith('.go')) {
                labels.push('go');
              } else if (filename.includes('security') || filename.includes('SECURITY')) {
                labels.push('security');
              }
            }

            // Add size label
            const additions = context.payload.pull_request.additions;
            const deletions = context.payload.pull_request.deletions;
            const changes = additions + deletions;

            if (changes < 10) {
              labels.push('size/xs');
            } else if (changes < 30) {
              labels.push('size/s');
            } else if (changes < 100) {
              labels.push('size/m');
            } else if (changes < 500) {
              labels.push('size/l');
            } else {
              labels.push('size/xl');
            }

            // Remove duplicates
            const uniqueLabels = [...new Set(labels)];

            if (uniqueLabels.length > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: uniqueLabels
              });

              console.log(`Added labels: ${uniqueLabels.join(', ')}`);
            }
